---
title: "Tidy First? 31. 결합도와 결합도 제거"
date: "241019"
tags: ["TidyFirst"]
---

> 정리하며 책의 문장을 요약해서 옮깁니다.

왜 결합도를 완전히 제거하지 않을까요? 도대체 결합도는 왜 있어야 할까요?

결합도는 깜깜한 바닥에 놓인 레고 조각들처럼 직접 밟아보기 전까지는 잘 드러나지 않습니다.

현금흐름할인은 일부 결합도를 설명합니다.

앞 장에서 설명한 것처럼 구현할 당시에는 결합도가 있어도 구현하는 것이 경제적이었습니다.

수익은 먼저, 비용은 나중에. 이제 그 '나중'이 왔습니다.

시스템에 결합도가 있어야 하는 또 다른 정당한 이유는 방금 전까지만 해도 문제가 되지 않았기 때문입니다.

결합도가 필요한 마지막 이유는 어떤 결합도 피할 수 없기 때문입니다.

그 이유에 대해 '확신에 찬 단언'보다 더 좋은 논거가 없는 것 같아 안타깝습니다.

결합도가 왜 있는지는 사실 중요하지 않습니다.

지금 결합도 비용을 지불할 것인지, 아니면 결합도를 없애는 비용을 지불할 것인지 선택의 기로에 서게 됩니다.

통신 프로토콜 예제를 통해 구체적으로 살펴보겠습니다.

```
Sender>>send()
    writeFeild1()
    writeField2()

Receiver>>receive()
    readField1()
    readField2()
```

두 함수 사이에는 결합도가 있습니다. 하나의 함수를 변경하면 다른 함수도 변경해야 합니다.

이러한 함수를 100번째 변경할 때쯤이면, 인터페이스로 쓰일 언어를 정의하게 되죠.

```
format = [
    {field: "1", type: "integer"},
    {field: "2", type: "string"}
]

Sender>>send()
    writeField(format)

Receiver>>receive()
    readField(format)
```

뿅! 결합도가 사라졌습니다. 이제 한 곳에서 format을 변경할 수 있습니다.

하지만 이렇게 한다고 결합도가 완전히 '사라진' 것은 아닙니다.

지금 우리가 한 것은, 구현 순서에 대해 더 많은 옵션을 제공한 것입니다.

제 믿음 중에서, 증명하거나 적절하게 설명할 수 없는 것이 하나 있습니다.

한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도가 커진다는 것입니다.

이것이 의미하는 실질적인 의미는 모든 결합을 다 색출하듯 없애려고 애쓰지 말아야 한다는 것입니다.

그렇다면 대체로 절충점을 찾을 수 있는 공간이 남게 됩니다.

결합도에 따른 비용을 지불할 수도 있고, 결합도 제거 비용을 지불하고 이점을 얻을 수도 있습니다.

소프트웨어 설계가 어려운 것은 당연합니다.

그리고 대인 관계에 대한 부분은 이 시리즈의 다음 책에서 다루도록 하겠습니다.
