---
title: "Server-Sent Events(SSE): 폴링 지옥에서 벗어나기"
date: "241016"
tags: ["NestJS"]
---

챕터 세미나에서 아래 영상을 보았습니다.

> [SLASH 24 - SSE 이벤트 푸쉬로 불필요한 Polling 제거하기](https://www.youtube.com/watch?v=ovGgdPPUZ2I)

SSE에 대한 내용을 정리해보았습니다.

## SSE가 등장하게 된 이유: 폴링 지옥

옛날에는 서버에서 클라이언트로 실시간 데이터를 보내는 게 간단하지 않았습니다.

HTTP 1.x에서는 요청이 있어야만 서버가 응답을 줄 수 있었거든요.

그런데 대시보드에서 주식 가격이든, 알림 시스템이든 실시간으로 데이터를 업데이트해야 하는 수요가 많아지기 시작했습니다.

#### 폴링과 롱 폴링의 문제점

"새 데이터 있나요?" 하고 계속 서버에 주기적으로 요청을 보내는 방식이 한동안 대세였습니다. 이것은 생각보다 비효율적입니다.

데이터가 없을 때도 계속 요청을 보내니까 서버 부하가 장난이 아니었습니다. 대규모 트래픽에서는 특히 리소스 낭비가 심했습니다.

그래서 나온 게 롱 폴링입니다.

요청을 보내면 서버가 새 데이터가 나올 때까지 기다렸다가 응답을 주는 방식인데, 문제는 각 연결을 오래 열어두는 것 자체가 부담스럽다는 것이었습니다.

서버 입장에선 계속 연결을 관리해야 하니까요.

## 웹소켓이 해결사?

웹소켓이 등장하면서 "이제 실시간 문제는 끝났다!"라는 분위기였습니다.

양방향 통신도 되고, 연결도 한 번만 하면 끝이니까요. 그런데 막상 써보니까 생각보다 복잡한 부분이 많았습니다.

- HTTP와 다른 프로토콜이라 프록시 서버나 방화벽을 통과할 때 문제가 생기는 경우가 종종 있었습니다.
- 단순히 서버가 데이터만 푸시하면 되는 경우에도 웹소켓을 쓰려니까 과잉 설계 느낌이 들었습니다.

알림 시스템이나 대시보드처럼 서버가 일방적으로 데이터를 보내는 경우, 굳이 웹소켓을 써야 할까? 이런 고민들이 생겼습니다.

## SSE의 등장: 실시간 데이터 푸시는 간단하게

그래서 등장한 게 Server-Sent Events(SSE)입니다.

이름에서 느껴지듯, 서버가 클라이언트로 일방적으로 데이터를 푸시하는 방식입니다.

기존의 HTTP/1.1 프로토콜 위에서 동작하기 때문에 별도의 프로토콜을 배우거나 복잡하게 셋업할 필요가 없습니다.

#### SSE의 장점

- 자동 재연결: 네트워크 문제로 연결이 끊어져도 클라이언트가 자동으로 재연결을 시도합니다.
- 간단한 설정: 그냥 HTTP 응답을 `text/event-stream` 형식으로 보내면 끝입니다.
- HTTP 인프라와 완벽 호환: 프록시나 방화벽에서 문제없이 작동합니다.

대규모 시스템에서는 이렇게 가볍고 단방향 통신만 필요한 상황에서 SSE를 활용하면 훨씬 편리합니다.

## 언제 SSE가 좋을까?

SSE는 서버가 주기적으로 데이터를 보내주는 대시보드나 알림 시스템에서 특히 유용합니다. 예를 들어

- 주식 시장 대시보드: 실시간으로 가격 변동을 클라이언트에 푸시할 때
- 알림 시스템: 새 이메일이나 시스템 이벤트 알림 등
- 로그 모니터링: 서버에서 발생하는 로그를 스트리밍으로 보내는 경우
- 스포츠 경기 스코어 업데이트: 경기가 진행될 때 점수 변동을 실시간으로 보여줄 때

양방향 통신이 필요 없는 경우에는 웹소켓보다 훨씬 간단하게 구현할 수 있습니다.

## SSE와 웹소켓: 언제 어떤 걸 쓸까?

"둘 다 실시간 통신이 되는데 뭐가 다른가요?"라는 질문이 떠오를 수 있습니다. 그래서 간단히 정리해 봤습니다.

| 특징               | SSE                        | 웹소켓                      |
| ------------------ | -------------------------- | --------------------------- |
| 통신 방향          | 단방향 (서버 → 클라이언트) | 양방향 (서버 ↔ 클라이언트) |
| 프로토콜           | HTTP 기반                  | WebSocket 프로토콜          |
| 자동 재연결        | 기본 지원                  | 직접 구현 필요              |
| 방화벽/프록시 통과 | 문제 없음                  | 가끔 문제 발생              |
| 사용 사례          | 실시간 알림, 대시보드      | 채팅, 게임, 양방향 통신     |

SSE는 단방향 푸시만 필요할 때가 좋고, 웹소켓은 양방향 통신이 필요한 경우에 적합합니다.

## NestJS에서의 SSE 구현 예제

마지막으로, 간단하게 NestJS로 SSE를 구현하는 방법을 소개합니다.

RxJS를 활용해 스트림을 다루기 때문에 NestJS와 잘 맞습니다.

```typescript
// events.controller.ts
import { Controller, Get, Sse, MessageEvent } from "@nestjs/common";
import { Observable, interval, map } from "rxjs";

@Controller("events")
export class EventsController {
  @Sse()
  @Get()
  sendEvents(): Observable<MessageEvent> {
    return interval(1000).pipe(
      map((count) => ({
        data: { time: new Date().toISOString(), count },
      }))
    );
  }
}
```

위 코드는 1초마다 서버에서 현재 시간과 카운트 값을 스트림으로 클라이언트에 보내는 예제입니다.

클라이언트에서는 `EventSource` 객체로 이 데이터를 받아올 수 있습니다.

```html
<!-- index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>NestJS SSE Demo</title>
  </head>
  <body>
    <h1>Server-Sent Events Demo</h1>
    <div id="events"></div>

    <script>
      const eventSource = new EventSource("/events");
      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        document.getElementById(
          "events"
        ).textContent = `Time: ${data.time}, Count: ${data.count}`;
      };
    </script>
  </body>
</html>
```

## 정리하며

실시간 시스템이라고 무조건 웹소켓으로 구현할 필요는 없습니다.

SSE는 폴링의 비효율성을 해결하고 웹소켓보다 간단한 대안으로 등장했습니다.

양방향 통신이 필요 없고, 서버에서 주기적으로 데이터만 보내야 할 때 SSE를 쓰는 게 좋습니다.
