---
title: "이벤트 기반 아키텍처"
date: "240924"
tags: ["Article"]
---

> https://newsletter.systemdesigncodex.com/p/3-interview-questions-on-event-driven?utm_campaign=post&utm_medium=web

챕터리드께서 아티클을 공유해주셨습니다.

이번에 다른 팀원이 고도화하는 피처는 비동기 백그라운드 처리가 중요하기에 이벤트 기반 아키텍처에 대해 논의하고 있었습니다.

이벤트 기반 패턴은 생소하기에 이 아티클을 읽고 정리해보고 싶었습니다.

## Competing Consumer Pattern (경쟁 소비자 패턴)

경쟁 소비자 패턴은 여러 소비자가 동시에 메시지를 처리하여 시스템의 처리량을 높이고 부하를 분산시키는 방법입니다.

이는 우리가 아는 큐를 활용한 가장 정직한 방법이라고 보면 됩니다.

#### 주요 특징

- 메시지 큐에서 여러 소비자가 동시에 메시지를 가져와 처리합니다.
- 각 소비자는 독립적으로 작동하며, 서로 경쟁하듯 메시지를 가져갑니다.
- 시스템의 부하에 따라 소비자를 동적으로 추가하거나 제거할 수 있습니다.

#### 장점

- 확장성: 처리해야 할 메시지가 많아지면 소비자를 추가하여 처리량을 높일 수 있습니다.
- 고가용성: 일부 소비자에 문제가 생겨도 다른 소비자가 계속 작업을 처리할 수 있습니다.
- 부하 분산: 작업을 여러 소비자에게 분산시켜 시스템의 전반적인 성능을 향상시킵니다.

#### 구현 시 고려사항

- 메시지 큐는 동시에 여러 소비자가 접근할 수 있어야 합니다.
- 각 메시지는 한 번만 처리되어야 합니다 (중복 처리 방지).
- 소비자 간의 작업 분배 방식을 결정해야 합니다 (라운드 로빈, 가중치 등).

## Retry Messages Pattern (메시지 재시도 패턴)

메시지 재시도 패턴은 일시적인 오류로 인해 실패한 메시지 처리를 자동으로 재시도하는 방법입니다.

#### 주요 구성 요소

- Main Queue: 메시지를 순차적으로 처리하는 큐
- Dead Letter Queue (DLQ): 여러 번 재시도 후에도 실패한 메시지를 저장하는 큐
- Retry Queue: 재시도할 메시지를 임시로 저장하는 큐
- 지수 백오프 전략: 재시도 간격을 점진적으로 늘리는 방법

#### 작동 방식

1. 메시지 처리 실패 시, 해당 메시지를 Retry Queue로 이동합니다.
2. 일정 시간 후 Retry Queue에서 메시지를 다시 가져와 처리를 시도합니다.
3. 재시도 실패 시, 지수 백오프 전략에 따라 대기 시간을 늘려 다시 Retry Queue에 넣습니다.
4. 정해진 최대 재시도 횟수를 초과하면 해당 메시지를 DLQ로 이동시킵니다.

#### 장점

- 일시적인 오류로 인한 메시지 손실을 방지합니다.
- 시스템의 복원력을 높입니다.
- 지수 백오프 전략으로 시스템에 과부하가 걸리는 것을 방지합니다.

#### 구현 시 고려사항

- 재시도 횟수와 간격을 적절히 설정해야 합니다.
- DLQ의 메시지를 모니터링하고 처리하는 프로세스가 필요합니다.
- 멱등성을 보장하여 같은 메시지가 여러 번 처리되어도 문제가 없도록 해야 합니다.

## Async Request-Response Pattern (비동기 요청-응답 패턴)

비동기 요청-응답 패턴은 동기식 통신의 한계를 극복하고 시스템의 확장성과 응답성을 높이는 방법입니다.

#### 작동 방식

1. 클라이언트가 요청을 메시지 큐에 발송합니다.
2. 서버는 메시지 큐에서 요청을 가져와 처리합니다.
3. 처리가 완료되면 서버는 응답을 별도의 응답 큐에 발송합니다.
4. 클라이언트는 응답 큐를 폴링하거나 콜백을 통해 응답을 받습니다.

#### 주요 구성 요소

- 요청 큐: 클라이언트의 요청을 저장하는 큐
- 응답 큐: 서버의 응답을 저장하는 큐
- 상관 ID: 요청과 응답을 매칭시키기 위한 고유 식별자

#### 장점

- 확장성: 클라이언트와 서버의 처리 속도 차이를 완충합니다.
- 느슨한 결합: 클라이언트와 서버가 직접 연결되지 않아 유연성이 높아집니다.
- 피크 부하 관리: 요청 큐가 버퍼 역할을 하여 갑작스러운 부하를 관리할 수 있습니다.

#### 구현 시 고려사항

- 상관 ID를 사용하여 요청과 응답을 정확히 매칭해야 합니다.
- 타임아웃 처리: 응답이 오지 않는 경우를 대비한 처리가 필요합니다.
- 응답 수신 방식: 폴링과 콜백 중 적절한 방식을 선택해야 합니다.

각 패턴의 특성을 이해하고 적절히 조합하여 사용하면 더욱 견고하고 효율적인 시스템을 구축할 수 있을 것 같습니다.

어떤게 구현할지 옆에서 지켜보며, 제가 도움드릴 수 있는 부분에 대해 고민해볼 생각입니다.
