---
title: "리플렉션"
date: "240823"
tags: ["JavaScrpt"]
---

## 리플렉션: 프로그래밍의 메타 차원

리플렉션은 프로그램이 자신의 구조와 동작을 검사하고 수정할 수 있는 능력을 말합니다.

이는 단순한 기능을 넘어 메타 프로그래밍으로 가는 새로운 차원을 열어줍니다.

## 언어 간 리플렉션 비교

각 언어마다 리플렉션 구현 방식이 다릅니다.

obj 객체의 myMethod 메서드를 호출하는 코드입니다.

인자로는 "argument"를 넘깁니다.

#### Java

```java
Method method = MyClass.class.getMethod("myMethod", String.class);
method.invoke(obj, "argument");
```

#### Python

```python
method = getattr(obj, "my_method")
method("argument")
```

#### JavaScript (ES6+)

```javascript
Reflect.get(obj, "myMethod").apply(obj, ["argument"]);
```

#### C#

```csharp
var method = typeof(MyClass).GetMethod("MyMethod");
method.Invoke(obj, new object[] { "argument" });
```

## 리플렉션 활용한 동적 프록시 생성

프록시 패턴을 리플렉션으로 구현하면 런타임에 객체의 동작을 수정할 수 있습니다.

```javascript
function createProxy(target, interceptor) {
  return new Proxy(target, {
    get(target, property, receiver) {
      if (typeof target[property] === "function") {
        return function (...args) {
          interceptor(property, args);
          return Reflect.apply(target[property], target, args);
        };
      }
      return Reflect.get(target, property, receiver);
    },
  });
}

const obj = {
  hello(name) {
    console.log(`Hello, ${name}!`);
  },
};

const proxiedObj = createProxy(obj, (method, args) => {
  console.log(`Method ${method} called with args: ${args}`);
});

proxiedObj.hello("World");
// 출력:
// Method hello called with args: World
// Hello, World!
```

이 코드는 자바스크립트에서 프록시 객체를 생성하는 함수입니다.

프록시를 사용하면 객체에 대한 접근을 가로채서, 그 동작을 수정하거나 제어할 수 있습니다.

`createProxy` 함수는 두 개의 매개변수를 받습니다:

- `target`: 프록시로 감싸고자 하는 원본 객체입니다.
- `interceptor`: 함수 호출을 가로채기 위해 사용되는 인터셉터 함수입니다.

이제 코드의 동작을 단계별로 설명해 보겠습니다.

1. 프록시 생성

   ```javascript
   return new Proxy(target, { ... });
   ```

   `new Proxy(target, handler)`는 `target` 객체에 대한 프록시를 생성합니다.

   여기서 `handler` 객체는 프록시로 가로채고자 하는 동작들을 정의하는 데 사용됩니다.

2. get 트랩 정의

   ```javascript
   get(target, property, receiver) {
   ```

   `get` 트랩은 객체의 속성에 접근할 때 호출됩니다. 이 함수는 세 가지 인자를 받습니다.

   - `target`: 원본 객체
   - `property`: 접근하려는 속성 이름
   - `receiver`: 프록시 객체 자체

3. 함수 속성인지 확인

   ```javascript
   if (typeof target[property] === "function") {
   ```

   이 부분은 접근한 속성이 함수인지 확인합니다. 만약 함수라면, 원본 함수를 호출하기 전에 인터셉터 함수를 호출하여 추가 동작을 수행하도록 합니다.

4. 함수 호출 시 인터셉터 실행

   ```javascript
   return function (...args) {
     interceptor(property, args);
     return Reflect.apply(target[property], target, args);
   };
   ```

   함수 속성에 접근할 경우, 이 익명 함수가 반환됩니다. 이 함수는

   - 먼저 `interceptor` 함수를 호출합니다. `interceptor(property, args)`는 속성 이름(`property`)과 인자(`args`)를 받아 처리합니다. 이를 통해 함수 호출 전에 추가 로직을 삽입할 수 있습니다.
   - 그 후, `Reflect.apply`를 사용해 원본 객체의 함수를 호출합니다. `Reflect.apply`는 지정한 `this`와 인자를 사용해 함수를 호출하는 메서드입니다.

5. 일반 속성에 대한 접근 처리

   ```javascript
   return Reflect.get(target, property, receiver);
   ```

   속성이 함수가 아닌 경우, `Reflect.get`을 사용하여 원본 객체의 속성 값을 그대로 반환합니다.

   `Reflect.get`은 `target[property]`와 동일하게 동작하지만, 프록시 환경에서 안전하게 호출할 수 있습니다.

이 `createProxy` 함수는 주어진 객체의 함수 호출을 가로채기 위해 프록시를 사용합니다.

함수가 호출되면, 먼저 `interceptor` 함수가 실행되고, 이후 원본 함수가 호출됩니다.

이로 인해 함수 호출 시 로그를 남기거나 특정 조건에 따라 동작을 변경하는 등의 다양한 작업을 수행할 수 있습니다.
