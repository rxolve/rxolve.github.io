---
title: "배열의 최대 부분 합: 카데인 알고리즘(Kadane's Algorithm)"
date: "240725"
tags: ["Algorithm"]
---

동적 프로그래밍(DP)은 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 기법임을 알았습니다.

DP의 응용이자 알고리즘의 단골 문제 중 하나인 배열 최대 부분 합을 효율적으로 해결하는 카데인 알고리즘에 대해 알아보겠습니다.

## 문제

다음과 같은 문제를 생각해봅시다.

> 주어진 정수 배열에서 연속된 부분 배열의 최대 합을 찾는 효율적인 알고리즘을 설계하고 구현하세요.

예를 들어, `[-2, 1, -3, 4, -1, 2, 1, -5, 4]` 배열이 주어졌다면, `[4, -1, 2, 1]`이 최대 합(6)을 가진 부분 배열입니다.

## 카데인 알고리즘

카데인 알고리즘은 이 문제를 O(n) 시간 복잡도와 O(1) 공간 복잡도로 해결할 수 있는 효율적인 방법입니다. 이 알고리즘의 핵심 아이디어는 각 위치에서 끝나는 최대 부분합을 계산하면서 전체 최대값을 추적하는 것입니다.

## 구현 코드

```typescript
function maxSubarraySum(arr: number[]): number {
  let maxSum: number = Number.NEGATIVE_INFINITY;
  let currentSum: number = 0;

  for (const num of arr) {
    currentSum = Math.max(num, currentSum + num);
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}

const arr: number[] = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
console.log(maxSubarraySum(arr)); // 출력: 6
```

1. `maxSum`을 음의 무한대로 초기화합니다. 이는 모든 요소가 음수인 경우를 처리하기 위함입니다.
2. `currentSum`을 0으로 초기화합니다.
3. 배열을 순회하면서 각 요소에 대해
   - `currentSum + num`과 `num` 중 큰 값을 선택합니다. 이는 현재 요소를 이전 부분 배열에 추가할지, 새로운 부분 배열을 시작할지 결정하는 것입니다.
   - `maxSum`을 갱신하여 전체 최대값을 추적합니다.
4. `maxSum`을 반환합니다.

## 복잡도

- 시간 복잡도: O(n), 배열을 한 번만 순회합니다.
- 공간 복잡도: O(1), 추가적인 배열이나 자료구조를 사용하지 않습니다.

## 카데인 알고리즘 vs 계단 문제

카데인 알고리즘과 DP 기본 계단 문제를 비교해보면 다음과 같은 차이점이 있습니다.

### 목적

- 계단 문제: 전체 계단을 오르는 과정에서의 최대 점수를 구합니다.
- 카데인 알고리즘: 연속된 부분 구간의 최대 합을 구합니다.

### 점화식

- 계단 문제: dp[i] = dp[i - 1] + dp[i - 2]
- 카데인 알고리즘: current_sum = max(num, current_sum + num)

### 메모리 사용

- 계단 문제: 일반적으로 모든 상태를 저장하는 DP 배열을 사용합니다 (O(n) 공간).
- 카데인 알고리즘: 상수 개의 변수만 사용하여 O(1) 공간으로 해결 가능합니다.

### 구현 복잡도

- 계단 문제: 오르는 조건에 따라 더 복잡한 로직과 조건문이 필요할 수 있습니다.
- 카데인 알고리즘: 간단한 로직으로 구현 가능합니다.

## 카데인 알고리즘 적용 가능성 판단하기

### 요구사항 분석

- 문제가 '최대화' 또는 '최소화'를 요구하는가?
- 연속된 부분 배열에 대한 문제인가?

### 데이터 구조 확인

- 입력이 1차원 배열 형태인가?
- 2차원 이상의 데이터 구조라면, 1차원으로 축소 가능한가?

### 연산의 결합성

- 문제에서 요구하는 연산이 결합법칙을 만족하는가?
  - 결합법칙: (a op b) op c = a op (b op c)
  - 예): 덧셈, 곱셈 연산

### 제약 조건 확인

- 부분 배열의 길이에 제한이 없는가?
- 연속된 요소들을 자유롭게 선택할 수 있는가?

### 최적 부분 구조 존재 여부

- 전체 문제의 최적해가 부분 문제의 최적해로부터 구성되는가?

### 그리디(Greedy)한 선택 가능성

- 각 단계에서 최선의 선택이 전체 해의 최적성을 보장하는가?

## 적용 가능성 판단 예시

다음은 몇 가지 문제에 대해 카데인 알고리즘의 적용 가능성을 판단하는 예시입니다.

### 주식 가격 변동에서 최대 이익을 얻을 수 있는 구간 찾기

- 분석: 연속된 부분 배열, 최대화 문제, 1차원 데이터, 덧셈 연산
- 판단: 카데인 알고리즘 적용 가능

### 배열에서 합이 정확히 K인 부분 배열 찾기

- 분석: 연속된 부분 배열이지만, 정확한 합을 요구함
- 판단: 카데인 알고리즘 직접 적용 불가, 수정된 접근 필요

### 2D 행렬에서 최대 합을 가진 직사각형 영역 찾기

- 분석: 2D 데이터지만 1D로 축소 가능, 최대화 문제
- 판단: 카데인 알고리즘을 반복 적용하여 해결 가능
- **다음에 풀어볼 예정입니다.**

### 배열에서 증가하는 부분 수열 중 합이 최대인 것 찾기

- 분석: 연속성 조건 없음, 증가 조건 추가
- 판단: 카데인 알고리즘 직접 적용 불가, 다른 DP 접근 필요

## 정리

- 항상 문제의 세부 조건을 주의 깊게 읽어야 합니다. 작은 조건 하나가 알고리즘의 적용 가능성을 바꿀 수 있습니다.
- 카데인 알고리즘을 직접 적용할 수 없더라도, 아이디어를 약간 변형하거나 전처리 과정을 추가하여 카데인 알고리즘을 적용할 수 있게 만들 수 있습니다.
