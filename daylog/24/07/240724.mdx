---
title: "가장 쉬운 DP 문제"
date: "240724"
tags: ["Algorithm"]
---

알고리즘 문제를 풀다 보면 피해나갈 수 없는 동적 프로그래밍(Dynamic Programming, DP)에 대해 정리해보려고 합니다.

제가 아는 가장 쉬운 문제와 함께 DP의 개념을 알아보겠습니다.

## DP란 무엇일까요?

DP는 큰 문제를 작은 문제들로 나누어 해결하는 방법입니다. 이미 계산한 작은 문제의 답을 기억해 두었다가 나중에 다시 사용하는 똑똑한 방법이죠.

(저는 작게 쪼개는 해결 방식을 참 좋아하는 것 같아요)

## DP의 3가지 핵심 원리

1. **문제 쪼개기**: 큰 문제를 작은 문제로 나눕니다.
2. **답 저장하기**: 작은 문제의 답을 저장해 둡니다.
3. **저장한 답 재사용하기**: 같은 작은 문제가 나오면 저장해 둔 답을 사용합니다.

## 문제: 계단 오르기

프로그래밍에서 DP를 어떻게 사용하는지 "계단 오르기" 문제로 알아봅시다.

### 문제 설명

- n개의 계단이 있습니다.
- 한 번에 1계단 또는 2계단을 오를 수 있습니다.
- n개의 계단을 오르는 방법의 수를 구해야 합니다.

### DP 적용

1. **작은 문제**: 1개, 2개, 3개... 의 계단을 오르는 방법의 수
2. **답 저장**: 각 계단 수에 대한 방법의 수를 배열에 저장
3. **재사용**: n번째 계단을 오르는 방법 = (n-1번째 계단 방법 수) + (n-2번째 계단 방법 수)

### 구현 코드

```typescript
function climbStairs(n: number): number {
  if (n <= 1) return 1;

  // dp 배열 초기화
  let dp: number[] = new Array(n + 1);

  // 기본 케이스
  dp[0] = 1;
  dp[1] = 1;

  // DP 로직
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  // n번째 계단을 오르는 방법의 수 반환
  return dp[n];
}

// 테스트
console.log(climbStairs(2)); // 출력: 2
console.log(climbStairs(3)); // 출력: 3
console.log(climbStairs(5)); // 출력: 8
```

이 코드는 다음과 같이 동작합니다:

1. `n`이 1 이하인 경우, 방법의 수는 1입니다.
2. `dp` 배열을 생성하여 각 계단에 도달하는 방법의 수를 저장합니다.
3. 기본 케이스: 0번째와 1번째 계단에 도달하는 방법의 수는 1입니다.
4. 2부터 n까지 반복하면서 각 계단에 도달하는 방법의 수를 계산합니다.
   i번째 계단에 도달하는 방법의 수는 (i-1)번째 계단에서 1계단 오르는 경우와
   (i-2)번째 계단에서 2계단 오르는 경우의 합입니다.
5. 마지막으로 n번째 계단에 도달하는 방법의 수를 반환합니다.

## 정리

이렇게 DP는 이전에 계산한 결과를 재사용하여 효율적으로 문제를 해결합니다. 큰 문제(n개의 계단 오르기)를 작은 문제(1, 2, 3... 개의 계단 오르기)로 나누고, 작은 문제의 해답을 이용해 큰 문제를 해결하는 것이죠.

간단한 DP 문제를 풀어봤습니다. 더 복잡한 문제도 도전해 보시길 바랍니다 🚀
