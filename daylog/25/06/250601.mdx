---
title: "Human coders are still better than LLMs"
date: "250601"
tags: ["Article"]
---

> https://antirez.com/news/153

antirez는 위 포스팅에서, AI 도구가 실용적인 코딩 업무를 보조하는 데 매우 유용하지만, 여전히 사람의 창의성과 지능을 대체하기에는 부족하다고 말합니다.
그는 자신이 Redis의 HNSW(Vector Sets) 구현 과정에서 복잡한 버그를 해결하기 위해 LLM(Gemini 2.5 PRO)을 활용했으나, 최종적으로는 인간만이 생각해낼 수 있는 XOR 기반의 간단하고 기발한 해법을 고안했다는 경험을 공유합니다.
LLM이 제공한 제안과 그 한계, 그리고 인간이 제시한 최종 해결책을 단계적으로 설명하며, 결국 복잡한 문제 해결에는 인간의 창의력이 여전히 우위를 차지한다고 강조합니다.

## 배경

#### Redis Vector Sets와 HNSW 구조

- antirez는 Redis에 HNSW(계층적 근접 이웃 탐색 구조, Hierarchical Navigable Small World)를 도입하여 대규모 벡터 데이터를 빠르게 저장하고 검색하는 기능을 구현하고 있었습니다.
- HNSW는 그래프 기반 데이터 구조로, 각 노드는 여러 레벨의 링크를 통해 다른 노드와 연결돼 있으며, 이를 통해 빠른 근접 이웃 탐색이 가능합니다.
- Redis 모듈로 구현할 때, 그래프 자체를 직렬화(serialization)하여 RDB에 저장하고, 복원 시 노드 간 포인터(pointer)로 재조립함으로써 성능을 극대화하는 방식을 사용했습니다.

#### 데이터 손상과 역링크(Reciprocal Links) 문제

- 하지만 RDB 파일이나 RESTORE 페이로드 처리 시 랜덤하게 발생하는 데이터 손상으로 인해, 노드 A와 노드 B 간의 상호 연결 상태가 깨질 수 있다. 예를 들어 A가 B를 가리키는데, B가 A를 가리키지 않는 경우가 발생할 수 있습니다.
- 이후 노드 B가 삭제될 때, A의 링크를 정리하지 못해 use-after-free(해제된 메모리를 참조) 오류로 이어질 위험이 있습니다.
- 이를 방지하려면 모든 링크가 상호적(recursive)인지 확인해야 하지만, 순수한 브루트포스 방식으로 모든 노드와 링크를 검사하면 O(N²) 시간이 걸려 대규모 벡터 세트(예: 2천만 개 벡터)의 로딩 시간이 두 배로 늘어났습니다.

## 주요 내용

#### 초기 접근 방식: 정렬 기반 바이너리 서치

- antirez는 먼저 전통적인 방법으로 각 노드의 링크 포인터 배열을 정렬한 뒤, 바이너리 서치를 통해 상대편 링크가 존재하는지 확인하도록 했습니다.
- 그러나 실제로 벡터 세트가 커질수록 정렬과 검색 오버헤드가 커져, 2천만 벡터 기준으로 로딩 시간이 45초에서 90초 이상으로 늘어났습니다.

#### LLM을 활용한 해법 모색

- antirez는 Gemini 2.5 PRO를 열어 “O(N²)에 가까운 검사를 줄일 수 있는 더 빠른 방법이 없느냐”고 물었으나, LLM이 제안한 최선의 방법은 “링크 포인터 배열을 정렬해 바이너리 서치를 활용하라”는 것이었습니다. 이는 이미 시도했던 방식이었습니다.
- 다음으로 해시 테이블 접근법을 제안받았는데, 링크를 키(key)로 생성해 해시맵에 넣고, 다시 만날 때 해시맵에서 지워서 최종적으로 해시맵이 비어 있으면 상호 링크가 모두 유효하다고 판단하는 방식이었습니다.
  - antirez는 snprintf() 기반 문자열 키 생성 오버헤드를 지적하며 memcpy()를 활용한 고정 크기 키 생성으로 개선할 여지를 제시하자, LLM도 이를 인정했습니다.

#### 인간의 창의적 해법: XOR 누산기

- 최종적으로 antirez가 떠올린 것은 해시 테이블조차 쓰지 않는 간단한 아이디어였습니다. 각 링크(A:B:X)를 수십 비트 고정 크기(예: 포인터 8바이트 + 포인터 8바이트 + 레벨 4바이트 = 20바이트)로 표현한 뒤, 이를 128비트 레지스터에 XOR 누적(accumulator)합니다.
- 순회하면서 모든 상호 링크가 등장할 때마다 같은 키가 두 번 XOR되어 0이 되고, 순회 후 레지스터 값이 0이 아니면 비대칭 링크가 존재한다고 판단하는 방식입니다. 이는 해시 테이블을 메모리와 처리 시간 측면에서 대폭 줄여줍니다.

#### LLM의 한계와 추가 방안

- 다만 이 XOR 기반 방식은 충돌(Collision) 가능성이 있어서, 적은 수의 비대칭 링크들이 서로 XOR해 0이 될 위험이 있습니다. 실제로 메모리 할당자는 예측 가능해, 공격자가 특정 비트 패턴을 노리기 쉽다는 점을 LLM도 지적했습니다.
- antirez는 이를 보완하기 위해 murmur-128 같은 빠른 해시 함수를 도입하되, 랜덤 시드(S)를 /dev/urandom에서 가져와 A:B:X 앞에 붙이고, murmur-128(S:A:B:X) 값을 128비트 레지스터에 XOR 누적하는 방안을 제시했습니다.
  - 시드를 모르는 외부 공격자가 비대칭 링크를 조작해도 0으로 누적될 가능성이 매우 낮아집니다.
- LLM은 이 개선책을 “충분히 실용적이며, 사용자가 기능을 켤 때 성능 저하도 크지 않아야 한다”는 점을 인정했으나, 여전히 ‘완전한 방어책’이라 보기는 어렵다고 답했습니다.

#### 인간과 LLM의 역할

- antirez는 이번 경험을 통해 “LLM은 아이디어를 공유하고 보완하는 데 훌륭한 ‘스마트 오리(duck)’ 역할을 하지만, 근본적인 창의력과 문제 인식 단계는 여전히 인간의 몫”이라고 결론짓습니다.
- 특히 복잡한 시스템 설계나 공격 시나리오를 고려한 보안적 관점에서는, LLM이 완벽한 해답을 주기보다 “사고 실마리(hint)” 정도만 줄 뿐이라고 강조합니다.

## 결론 및 시사점

1. LLM은 보조 도구, 창의적 해결은 인간 몫

   - LLM은 빠른 코드 생성, 아이디어 스케치, 테스트 케이스 작성 등 다방면에서 인간 개발자의 효율을 크게 높여 주지만, 근본적인 문제 정의와 참신한 사고 과정까지 책임지지는 못합니다.
   - 복잡한 버그나 공격 시나리오를 고려한 설계 단계에서는, 인간의 도메인 지식과 창의력이 여전히 핵심입니다.

2. 실용적인 알고리즘 설계: 간단하지만 강력한 해법

   - 이번 사례에서처럼 해시 테이블 대신 고정 크기 XOR 누산기를 활용한 방법은, 메모리와 시간 복잡도를 획기적으로 줄일 수 있는 좋은 예시입니다.
   - LLM이 제안한 방법을 검토하고, 인간이 추가 개선 아이디어(예: memcpy 키, 무작위 시드 기반 해싱)를 부여해 실용적인 최적 해법을 만드는 과정이 중요합니다.

3. LLM 활용 시 주의점
   - LLM 제안만 무비판적으로 받아들일 경우, 제안된 알고리즘의 실제 성능이나 보안 취약점을 간과할 위험이 있습니다.
   - 따라서 LLM이 제안한 아이디어를 “검증→개선→검증”하는 인간 중심 프로세스를 반드시 거쳐야 합니다.
