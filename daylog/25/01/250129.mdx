---
title: "Raft 합의 알고리즘"
date: "250129"
tags: ["Algorithm"]
---

## Raft의 기본 개념

분산 시스템은 여러 서버(노드)가 네트워크를 통해 협력하면서도 개별 장애에 견딜 수 있어야 합니다.  
Raft는 이러한 환경에서 모든 노드가 동일한 “상태 머신(state machine)”을 실행하도록 보장하는 알고리즘입니다.  
주요 목표는 다음과 같습니다.

- 명료성: Paxos보다 이해하기 쉽고 구현이 용이함
- 안정성: 일부 노드 장애에도 시스템 전체의 일관성을 유지
- 효율성: 로그 복제와 리더 선출을 통해 분산 시스템의 성능 최적화

## 주요 구성 요소

#### 리더(Leader)

클러스터 내에서 단 한 개의 리더가 존재하며, 클라이언트의 모든 요청을 처리하고 로그를 팔로워들에게 복제합니다.  
리더는 주기적으로 하트비트(heartbeat) 메시지를 보내어 자신의 존재를 알리고 팔로워들의 타임아웃을 초기화합니다.

#### 팔로워(Follower)

리더로부터 전파되는 로그 복제와 하트비트를 수신하며, 별도의 요청 없이 수동적으로 동작합니다.  
만약 일정 시간 동안 리더의 메시지를 받지 못하면, 자신을 후보로 전환하게 됩니다.

#### 후보자(Candidate)

리더가 부재하거나 실패한 경우, 팔로워는 후보자로 전환되어 새로운 리더를 선출하기 위한 투표를 요청합니다.

## Raft의 동작 원리

#### 리더 선출 (Leader Election)

1. 타임아웃: 각 팔로워는 랜덤화된 선거 타임아웃을 가지고 있으며, 타임아웃이 경과하면 후보자로 전환합니다.
2. 투표 요청: 후보자는 자신에게 투표해달라는 요청 메시지를 클러스터 내 모든 노드에 전송합니다.
3. 과반수 득표: 전체 노드의 과반수(Quorum)의 투표를 받으면 해당 후보자가 리더로 선출됩니다.
4. 하트비트: 선출된 리더는 하트비트 메시지를 주기적으로 전송하여 팔로워들의 타임아웃을 재설정합니다.

#### 로그 복제 (Log Replication)

1. 클라이언트 요청: 클라이언트가 명령(예: 상태 변경 요청)을 보내면, 리더는 새로운 로그 엔트리를 생성하여 자신의 로그에 기록합니다.
2. 전파: 리더는 생성된 로그 엔트리를 모든 팔로워에게 전파합니다.
3. 확인 응답: 각 팔로워는 해당 로그 엔트리를 받아 자신의 로그에 추가한 후, 리더에게 성공 여부를 응답합니다.
4. 커밋: 리더는 과반수 노드가 동일 로그 엔트리를 보유한 것을 확인하면, 해당 로그를 “커밋(commit)” 상태로 전환하고, 클라이언트에게 결과를 반환합니다.

#### 안전성 보장 (Safety)

Raft는 임기(term)와 로그 일관성 검사 등을 통해 다음과 같은 안전성을 확보합니다.

- 임기(Term): 각 리더 선출 및 로그 엔트리에는 임기 번호가 할당되어, 새로운 임기에서는 이전 임기의 로그가 무효화되지 않도록 합니다.
- 일관성 검사: 각 노드는 자신의 로그가 “최신”인지 확인하며, 로그 불일치 시 스냅샷(snapshot) 전송 등으로 복구합니다.

## 왜 Raft인가?

Raft는 “이해하기 쉬운 합의 알고리즘”을 목표로 만들어졌습니다.  
Paxos가 수학적으로 복잡하고 구현이 어려워 실제 시스템에 적용하는 데 한계가 있었던 반면, Raft는 다음과 같은 점에서 장점을 가집니다.

- 명확한 역할 구분: 리더, 팔로워, 후보자의 역할이 명확히 구분되어 있어 각 노드의 동작을 쉽게 파악할 수 있습니다.
- 단계별 접근: 리더 선출, 로그 복제, 안전성 보장을 별도의 단계로 나누어 설명하고 구현할 수 있으므로 디버깅과 유지보수가 용이합니다.
- 실제 구현 사례: Kubernetes의 etcd, MongoDB의 레플리카 셋 등 여러 실제 시스템에서 Raft를 채택하여 검증된 안정성을 보여줍니다.
