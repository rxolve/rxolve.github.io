---
title: "API 중복 요청 방지하기"
date: "250404"
tags: ["NestJS"]
---

동시성 환경에서 API POST 요청이 동시에 들어왔을 때, 동일한 리소스가 여러 번 생성되는 문제는 실제 운영 환경에서 치명적인 이슈로 이어질 수 있습니다.  
예를 들어 결제, 회원 가입, 주문 생성 등에서는 한 건의 요청만 처리되어야 하는데, 중복 생성이 발생하면 사용자 신뢰도 하락 및 재무적인 문제로 이어질 수 있습니다.
여기서는 이런 문제를 예방할 수 있는 여러 가지 접근 방법과 각 방법의 장단점을 정리해 보겠습니다.

## 왜 중복 생성이 발생할까?

동일한 API POST 요청이 동시에 들어올 경우, 여러 스레드(또는 프로세스)가 거의 동시에 데이터베이스에 접근하게 됩니다.  
이때,

- 레이스 컨디션(Race Condition): 여러 요청이 동시에 DB에 삽입을 시도하면, 어느 한 요청이 먼저 생성하고 그 사이에 다른 요청이 이미 동일한 데이터를 기반으로 삽입하려 하면서 중복이 발생할 수 있습니다.
- 비멱등성(Non-Idempotency): POST 요청은 기본적으로 멱등성이 보장되지 않습니다. 같은 요청을 여러 번 보내면 매번 새로운 리소스가 생성됩니다.

## 중복을 막기 위한 접근 방법

#### 데이터베이스 레벨의 유니크 제약 조건

설명:

- 복합 유니크 인덱스를 사용하여, 특정 컬럼 조합(예: 사용자 ID, 주문 번호, 상태 등)이 중복되지 않도록 DB에 제약을 걸 수 있습니다.
- 예를 들어, MySQL에서는 아래와 같이 테이블 생성 시 복합 유니크 키를 정의할 수 있습니다.

  ```sql
  CREATE TABLE orders (
      id INT AUTO_INCREMENT PRIMARY KEY,
      user_id INT NOT NULL,
      order_number VARCHAR(50) NOT NULL,
      status VARCHAR(20) NOT NULL,
      amount DECIMAL(10,2),
      -- 기타 컬럼들...
      UNIQUE KEY unique_order (user_id, order_number, status)
  ) ENGINE=InnoDB;
  ```

장점:

- DB 수준에서 중복을 완벽하게 차단하므로, 어떤 애플리케이션 로직의 오류보다도 안전하게 중복 삽입을 막을 수 있습니다.

단점:

- 동시성 상황에서 중복 삽입 시도 시 예외가 발생하므로, 애플리케이션에서 이 예외를 처리하고 사용자에게 적절한 메시지를 전달해야 합니다.
- 일부 경우에는 DB 락 경합으로 인해 성능 이슈가 발생할 수도 있습니다.

#### Idempotency Key (멱등성 키) 도입

설명:

- 클라이언트가 각 POST 요청 시 고유한 Idempotency Key(예: UUID)를 함께 전송합니다.
- 서버는 이 키를 기반으로 이미 처리한 요청인지 확인합니다.
  - 처리된 요청: 동일한 키로 들어온 후속 요청에 대해서는 기존의 결과를 재전송하거나 무시합니다.
  - 새로운 요청: 키가 없으면 정상 처리 후, 키와 함께 결과를 저장해 둡니다.

장점:

- 클라이언트와 서버 양쪽에서 중복 요청을 사전에 인지할 수 있으므로, 중복 생성을 효과적으로 방지할 수 있습니다.
- 네트워크 장애 등으로 인한 재시도 시에도 안전하게 작동합니다.

단점:

- 클라이언트가 키를 제대로 관리하지 않으면 중복 판단에 오류가 생길 수 있습니다.
- 서버는 Idempotency Key를 저장할 별도의 저장소(예: 메모리, Redis, DB 테이블 등)를 관리해야 합니다.

#### 분산 락 (Distributed Locking)

설명:

- Redis와 같은 분산 캐시 시스템을 이용해, 특정 리소스에 대한 락을 획득한 후에만 생성 작업을 수행합니다.
- 예를 들어, “order:12345”와 같이 고유 식별자를 락 키로 사용하여, 락이 이미 존재하면 다른 요청은 대기하거나 거부하도록 구현합니다.

장점:

- 멀티 서버 환경에서도 단일 요청만 처리하도록 강제할 수 있습니다.
- 일시적인 트래픽 폭주 상황에서 유용합니다.

단점:

- 락 획득 및 해제 로직 구현이 추가되며, 락 서버(Redis 등)에 부하가 발생할 수 있습니다.
- 락의 유효시간 및 해제 타이밍 관리에 신경 써야 합니다.

#### 요청 큐잉 (Queuing Mechanism)

설명:

- 모든 POST 요청을 큐에 넣고, 하나씩 순차적으로 처리하도록 설계합니다.
- 큐 시스템(예: RabbitMQ, Kafka 등)을 이용해 처리 순서를 보장하고, 동시에 처리되는 요청을 직렬화할 수 있습니다.

장점:

- 요청 순서를 보장하므로, 중복 생성을 효과적으로 막을 수 있습니다.
- 트래픽이 과도한 상황에서도 안정적으로 작동합니다.

단점:

- 큐 시스템의 도입으로 아키텍처 복잡성이 증가합니다.
- 실시간 응답 지연이 발생할 수 있습니다.

## 결합된 전략

실제 운영 환경에서는 하나의 방법만으로는 모든 상황을 커버하기 어려울 수 있습니다.  
일반적으로는 다음과 같이 결합된 전략을 사용하는 것이 좋습니다.

- DB 유니크 제약 조건: 최후의 안전망으로 항상 중복 데이터 생성을 방지합니다.
- Idempotency Key: 클라이언트와 서버 간에 중복 요청을 사전에 차단하고, 재시도 상황에서도 안정적인 응답을 보장합니다.
- 분산 락: 동시성 문제에 민감한 핵심 로직(예: 결제 처리)이 필요한 경우 추가적으로 적용합니다.

이와 같이 여러 계층에서 중복 생성을 방지하는 로직을 도입하면, 단일 실패 지점을 최소화하고 시스템 전반의 견고함을 높일 수 있습니다.
