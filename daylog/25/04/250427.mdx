---
title: "빈스톡 간 502 오류 분석 및 해결 방안"
date: "250427"
tags: ["AWS"]
---

## 502 에러의 일반적 원인

HTTP 502 Bad Gateway는 중간 프록시나 로드 밸런서(LB)가 타겟 서버로부터 유효한 응답을 받지 못했음을 나타냅니다 ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=HTTP%20502%20errors%20are%20usually,for%20some%20or%20other%20reason)). 일반적인 원인으로는 타겟 연결 실패(예: 서버 다운, 보안그룹/ACL 차단), 타겟이 연결을 조기에 종료함(Keep-Alive 불일치) ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,value%20of%20the%20load%20balancer)) ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)), 응답 헤더 이상(크기 초과, 형식 오류), Deregister 된 인스턴스의 요청 처리 중단 등이 있습니다 ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,value%20of%20the%20load%20balancer)) ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)). 특히 ALB의 기본 유지 연결(Idle) 타임아웃(60초)보다 타겟 서버의 Keep-Alive 타임아웃이 짧으면, 타겟이 연결을 닫을 때 LB가 502를 반환할 수 있습니다 ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)) ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,value%20of%20the%20load%20balancer)). 또한 타겟 그룹의 비정상(실패) 인스턴스가 모든 요청을 처리하지 못하면 502/503이 발생할 수 있습니다.

## 원인 분석

- 로드 밸런서 문제: ELB(ALB) 앞단에서 요청이 차단되거나 연결이 조기에 종료될 수 있습니다. 예를 들어, ALB의 idle 타임아웃(기본 60초)이 NestJS/Node 기본 Keep-Alive 타임아웃(5초)보다 길면, 타겟(Nginx/Node)이 연결을 닫을 때 ALB가 502 에러를 낼 수 있습니다 ([Tuning HTTP Keep-Alive in Node.js](https://connectreport.com/blog/tuning-http-keep-alive-in-node-js/#:~:text=the%20socket%20for%20the%20connection,the%20persistent%20connection%20timeout%20behavior)) ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)).
- NestJS/Express 설정: NestJS(Express) 서버의 `keepAliveTimeout` 기본값이 5초 ([Tuning HTTP Keep-Alive in Node.js](https://connectreport.com/blog/tuning-http-keep-alive-in-node-js/#:~:text=the%20socket%20for%20the%20connection,the%20persistent%20connection%20timeout%20behavior))이므로, 부하 시간대에 재사용 연결 시 서버가 연결을 닫아버리면 502로 이어질 수 있습니다. 서버의 `headersTimeout` 등도 기본값을 확인해야 합니다.
- Nginx(Beanstalk 프록시) 타임아웃: Elastic Beanstalk Node 플랫폼은 기본적으로 Nginx를 리버스 프록시로 사용합니다. Nginx의 기본 `keepalive_timeout`은 75초 ([http - What's the difference between Nginx 'keepalive_time' and 'keepalive_timeout'? - Server Fault](https://serverfault.com/questions/1121478/whats-the-difference-between-nginx-keepalive-time-and-keepalive-timeout#:~:text=keepalive_timeout%20is%20the%20time%20where,keepalive_time)), `proxy_*_timeout`은 60초(또는 75초) 정도로 알려져 있으며, 이보다 짧은 응답 지연 시 요청을 중단할 수 있습니다.
- 시스템 과부하: 마켓 서비스의 CPU/메모리 과부하나 이벤트 루프 지연으로 인해 요청 처리 자체가 지연되면, 응답 타임아웃 또는 연결 실패로 502가 발생할 수 있습니다. (예: GC/CPU spike, DB 커넥션 고갈, TypeORM 커넥션 풀 부족 등)
- 네트워크/보안그룹: ALB → 인스턴스간 SG 설정 오류나 네트워크 ACL 문제로 특정 AZ에서 연결이 차단되면 502가 나타날 수 있습니다. 보안 그룹에서 ALB의 아웃바운드 및 인스턴스의 인바운드 규칙(특히 HTTP/HTTPS 포트)이 올바른지 확인해야 합니다.
- 건강 상태 및 스케일: EB 인스턴스의 상태가 `Deregistering` 상태이거나 헬스체크에 실패하면 해당 인스턴스에 보내진 요청이 502로 처리될 수 있습니다 ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,that%20lengthy%20operations%20can%20complete)). 오토스케일링 정책이나 헬스체크 설정(경로, 타임아웃, 임계치)을 점검합니다.

## Elastic Load Balancer 설정 및 동작 점검

- Idle Timeout 확인: ALB의 기본 idle 타임아웃은 60초이며, 이를 초과하면 연결을 닫고 504/502를 반환할 수 있습니다 ([Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#:~:text=)) ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)). 서버 측 타임아웃(keepAlive, proxy timeout 등)보다 크면 LB가 먼저 끊을 수 있으므로, 필요 시 idle 타임아웃을 증가(예: 60→120초)하거나 서버 측 Keep-Alive를 연장합니다.
- 타겟 그룹 헬스 체크: 헬스체크 경로(`/health` 등)와 정상 응답 코드를 적절히 설정하고, 실패 임계치ㆍ인터벌 시간을 검토합니다. 헬스체크 실패로 인스턴스가 비정상으로 간주되면 트래픽이 분배되지 않으므로, 동시 부하 증가 시 인스턴스 보유 대수를 늘려 안정성을 확보합니다.
- 보안 설정: ALB 보안그룹에서 HTTP/HTTPS(80/443) 트래픽이 허용되고, 인스턴스 보안그룹에서 ALB의 SG를 신뢰하도록 설정되었는지 확인합니다. NACL 등 네트워크 구성이 ALB 서브넷과 대상 간 통신(1024-65535 에페멀 포트)이 허용되는지도 점검합니다.
- 로드 밸런서 유형 검토: HTTP/L7 기능이 필요치 않다면, Network Load Balancer(NLB)로 전환을 검토할 수 있습니다. NLB는 TCP 350초 기본 idle 타임아웃(조정 가능, 기본 350초) ([Network Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#:~:text=The%20default%20idle%20timeout%20value,packets%20sent%20to%20maintain%20TLS))을 제공하므로, 연결 유지로 인한 문제 가능성이 낮습니다. 다만 NLB는 HTTP 상태 코드를 해석하지 않고 502 오류도 발생시키지 않으므로, 애플리케이션 관점에서 차이가 있습니다.
- 접속 로깅 및 지표: ALB 액세스 로그를 활성화하여 502 발생 시점의 타겟 응답 코드와 LB 응답 코드를 확인합니다. CloudWatch의 `HTTPCode_ELB_502_Count`와 `HTTPCode_Target_5XX_Count` 등 지표로 문제 발생 패턴을 분석합니다. AWS 지원 문서에서도 502 발생 시, “keep-alive 타임아웃과 idle 타임아웃 불일치”를 주요 원인으로 지적합니다 ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)).

## NestJS 및 Axios 타임아웃/오류 핸들링

- Axios 기본 설정: Axios의 기본 `timeout` 값은 0(무제한) ([What is Axios default timeout - Stack Overflow](https://stackoverflow.com/questions/57995863/what-is-axios-default-timeout#:~:text=105))입니다. 따라서 별도 `timeout` 설정이 없으면 요청이 끝없이 대기할 수 있습니다. 필요 시 `axios.create({ timeout: N })` 또는 NestJS `HttpModule.register({ timeout: N })`로 타임아웃을 명시해야 합니다. 타임아웃 발생 시 Axios 에러(`ECONNABORTED`)를 적절히 캐치하여 재시도 로직이나 사용자 예외로 처리합니다.
- Keep-Alive 사용: 기본 Axios는 매 요청마다 새 연결을 사용하므로(ephemeral port 사용), `http.Agent` 및 `https.Agent`를 `keepAlive: true`로 설정하여 커넥션을 재사용하도록 구성할 수 있습니다 ([javascript - Enabling 'keepAlive' functionality in Axios and NodeJS - Stack Overflow](https://stackoverflow.com/questions/71441860/enabling-keepalive-functionality-in-axios-and-nodejs#:~:text=const%20httpAgent%20%3D%20new%20http.Agent%28,httpAgent%3A%20httpAgent%2C%20httpsAgent%3A%20httpsAgent)). 예를 들어:
  ```js
  const agent = new http.Agent({ keepAlive: true });
  axios.get(url, { httpAgent: agent });
  ```
  이렇게 하면 다수 요청 시 소켓 생성 오버헤드와 TIME_WAIT 문제를 줄일 수 있습니다.
- NestJS 서버 설정: NestJS(Express)에서 HTTP 서버를 직접 제어할 경우, `const server = app.getHttpServer()` 등의 방법으로 `server.keepAliveTimeout`과 `server.headersTimeout`을 조정할 수 있습니다. 기본 keepAliveTimeout은 5000ms ([Tuning HTTP Keep-Alive in Node.js](https://connectreport.com/blog/tuning-http-keep-alive-in-node-js/#:~:text=the%20socket%20for%20the%20connection,the%20persistent%20connection%20timeout%20behavior))이며, ALB idle 이상(예: 60000ms)으로 늘려두면 연결 조기 종료 위험을 줄일 수 있습니다.
- 오류 핸들링: 네트워크나 타임아웃 오류가 발생하면 NestJS에서 이를 잡아내고 적절히 로그를 남겨야 합니다. 예를 들어 `HttpService` 사용 시 `lastValueFrom(this.httpService.get(...))`과 `try/catch` 블록을 이용하여 예외를 처리하거나, Observable의 `catchError`로 전파합니다. 에러 발생 시, 내부 로깅 시스템(CW Logs)과 통합하여 재현 시점을 파악하도록 합니다.

## 타임아웃 발생 시 점검사항 (클라이언트/서버)

- 클라이언트(엑스퍼트) 측: Axios 설정(`timeout`, `maxRedirects`, `headers`) 및 커넥션 설정(Http/HTTPS Agent)이 적절한지 확인합니다. DNS 해석 문제, 방화벽/프록시 여부, 환경변수(`NO_PROXY`) 등 네트워크 설정도 점검합니다. 다중 요청 상황에서는 커넥션 풀이 포화되어 있지 않은지(`maxSockets`) 확인합니다.
- 서버(마켓) 측: 인스턴스의 CPU, 메모리, 이벤트 루프 지연 등을 모니터링합니다. 높은 CPU 사용률이나 GC 지연 시 서비스 응답이 느려질 수 있습니다. Node.js 이벤트 루프 지연(lag)이 큰지(`cpu_utilization`, `pm2 metrics` 등) 확인하고, 필요하면 인스턴스 스케일 아웃을 고려합니다.
- 인프라: ALB 타겟 그룹의 각 인스턴스 상태 및 응답 시간, Nginx 에러 로그(`/var/log/nginx/…`), 애플리케이션 로그를 분석합니다. AWS CloudWatch 로그 그룹(Beanstalk, Lambda)과 X-Ray 추적을 통해 타임아웃 발생 구간을 정밀 조사합니다.
- 데이터베이스: RDS 연결 수 제한이나 지연 여부를 확인합니다. (현재 DB 클러스터는 정상이나, 부하 시 리전 제약이나 슬레이브 지연 가능성을 배제하지 않습니다.) TypeORM 커넥션 풀 크기, 쿼리 성능도 검토합니다.

## ALB/NLB, 헬스체크, 대상 그룹 설정 개선 방향

- ALB idle 타임아웃 증가: ALB idle 타임아웃(기본 60초)보다 서버 Keep-Alive/읽기 타임아웃이 짧지 않도록 조정합니다. 예를 들어 ALB idle을 120초로 설정하거나, 서버 측 타임아웃을 60초 이상으로 높입니다.
- 대상 그룹 설정: HTTP/HTTPS 리스너 및 대상 그룹 프로토콜이 올바른지 확인합니다. 헬스체크 경로(`/health` 등)와 포트, 정상코드(200) 외에 타겟 상태코드 설정이 적절한지 검토합니다. ‘연결 종료 지연(Deregistration Delay)’ 값을 길게(예: 300초) 설정하면, 노드 종료 시 기존 요청을 더 길게 처리할 수 있어 502/503을 줄일 수 있습니다 ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,that%20lengthy%20operations%20can%20complete)).
- NLB 고려: 트래픽이 많은 경우 NLB를 사용해 TCP 수준에서 로드 밸런싱하면 응답 지연에 따른 가변성을 줄일 수 있습니다. NLB는 350초 기본 타임아웃을 가지므로 ALB보다 연결 유지가 유리합니다 ([Network Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#:~:text=The%20default%20idle%20timeout%20value,packets%20sent%20to%20maintain%20TLS)). 다만 HTTP 특성이 필요하다면 ALB를 유지하며 설정을 최적화해야 합니다.
- Beanstalk 헬스 체크: EB 환경의 헬스 체크 설정(헬스 체크 사용/비사용, 주기, 응답 대기 시간)도 검토합니다. 애플리케이션이 시작되기 전 호출을 받지 않도록 초기 지연 시간을 늘리거나, 헬스 체크 경로를 경량 엔드포인트로 지정하여 초기 롤링 중단을 방지합니다.

## 조치 및 권장 설정 요약

- 타임아웃 조정: NestJS 서버(`server.keepAliveTimeout`/`headersTimeout`)와 Nginx(`keepalive_timeout`, `proxy_read_timeout`, `proxy_send_timeout` 등) 타임아웃을 기본 값(5~60초)보다 크게 설정합니다 ([Tuning HTTP Keep-Alive in Node.js](https://connectreport.com/blog/tuning-http-keep-alive-in-node-js/#:~:text=the%20socket%20for%20the%20connection,the%20persistent%20connection%20timeout%20behavior)) ([node.js - aws beanstalk nodejs: how to override 60s timeout of nginx - Stack Overflow](https://stackoverflow.com/questions/63672302/aws-beanstalk-nodejs-how-to-override-60s-timeout-of-nginx#:~:text=Therefore%2C%20you%20could%20have%20the,with%20content)). 예를 들어 `.platform/nginx/conf.d/timeout.conf`에 600초로 설정하면 응답 지연 처리 여유를 확보할 수 있습니다 ([node.js - aws beanstalk nodejs: how to override 60s timeout of nginx - Stack Overflow](https://stackoverflow.com/questions/63672302/aws-beanstalk-nodejs-how-to-override-60s-timeout-of-nginx#:~:text=Content%20of%20File%201%20,folder)) ([node.js - aws beanstalk nodejs: how to override 60s timeout of nginx - Stack Overflow](https://stackoverflow.com/questions/63672302/aws-beanstalk-nodejs-how-to-override-60s-timeout-of-nginx#:~:text=Therefore%2C%20you%20could%20have%20the,with%20content)).
- ELB 설정: ALB idle 타임아웃을 늘리고, 대상 그룹의 헬스체크 및 deregistration delay 설정을 최적화합니다. 가능 시 NLB 전환 또는 교차 AZ(Target Group의 AZ 균일 분포) 설정으로 고가용성을 확보합니다. ALB 액세스 로그 및 CloudWatch 지표로 502 발생 패턴을 모니터링합니다.
- Axios 및 HTTP 설정: 클라이언트에서 Axios 인스턴스에 HTTP(S) Agent `keepAlive: true`를 적용하여 연결을 재사용합니다. 필요 시 `timeout` 값을 명시적으로 설정하여 무한 대기를 방지합니다. NestJS의 HttpModule 사용 시 설정을 활용해 전역 타임아웃을 관리합니다.
- 스케일 및 자원 확보: 부하 시간대에 처리 용량을 충분히 확보합니다. EB Auto Scaling 설정을 검토하여 인스턴스 수를 늘리거나, 더 고성능 인스턴스로 전환합니다. DB 및 네트워크 병목도 병행 점검합니다.

## 핵심 요점 정리

| 이슈/원인                      | 영향 및 증상                                                                                                                                                                                                                                                                                           | 점검·조치 방안                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| LB 타임아웃/Keep-Alive 불일치  | 타겟이 응답 처리 중 연결을 조기 종료 → ALB가 502 반환 ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer))                                                     | ALB idle 타임아웃(기본 60초) 증가 또는 NestJS/Node keepAliveTimeout 연장 ([node.js - AWS Load Balancer 502 Bad Gateway - Stack Overflow](https://stackoverflow.com/questions/68729329/aws-load-balancer-502-bad-gateway#:~:text=,value%20of%20the%20load%20balancer)) ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,value%20of%20the%20load%20balancer))                                                                                             |
| Node/NestJS 기본 타임아웃      | 기본 `keepAliveTimeout=5초` ([Tuning HTTP Keep-Alive in Node.js](https://connectreport.com/blog/tuning-http-keep-alive-in-node-js/#:~:text=the%20socket%20for%20the%20connection,the%20persistent%20connection%20timeout%20behavior))로 인한 연결 종료                                                 | Node.js `server.keepAliveTimeout`를 60000ms 이상으로 설정, `headersTimeout > keepAliveTimeout` 설정                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Nginx 프록시 타임아웃          | 기본 `keepalive_timeout=75s`/`proxy_*_timeout=60s` 이내 처리 지연 시 연결 중단                                                                                                                                                                                                                         | `.platform/nginx/conf.d/`에 `keepalive_timeout`, `proxy_read_timeout` 등 연장 설정 ([node.js - aws beanstalk nodejs: how to override 60s timeout of nginx - Stack Overflow](https://stackoverflow.com/questions/63672302/aws-beanstalk-nodejs-how-to-override-60s-timeout-of-nginx#:~:text=Content%20of%20File%201%20,folder)) ([node.js - aws beanstalk nodejs: how to override 60s timeout of nginx - Stack Overflow](https://stackoverflow.com/questions/63672302/aws-beanstalk-nodejs-how-to-override-60s-timeout-of-nginx#:~:text=Therefore%2C%20you%20could%20have%20the,with%20content)) |
| axios 설정                     | 기본 타임아웃 0 (무제한) ([What is Axios default timeout - Stack Overflow](https://stackoverflow.com/questions/57995863/what-is-axios-default-timeout#:~:text=105)) 또는 연결 재사용 미사용                                                                                                            | `axios.create({ timeout: N })`로 타임아웃 설정, `http(s).Agent({keepAlive:true})`로 커넥션 재사용 구현                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 대상 그룹 헬스체크/드레인 설정 | 헬스체크 실패 또는 드레인 시간 부족 시 인스턴스 제외/요청 중단 ([Troubleshoot your Application Load Balancers - Elastic Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-troubleshooting.html#:~:text=,that%20lengthy%20operations%20can%20complete)) | 헬스체크 경로/간격/임계치 조정, deregistration delay 연장(예: 300s)로 연결 유지                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 보안/네트워크 설정             | SG/NACL 차단으로 ALB↔인스턴스 연결 불가                                                                                                                                                                                                                                                               | ALB 보안그룹의 인바운드, 인스턴스 SG의 아웃바운드 규칙 점검(HTTP/1024-65535 등 허용)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 리소스 과부하                  | 이벤트 루프 지연, 과도한 응답시간으로 타임아웃                                                                                                                                                                                                                                                         | CPU/메모리 모니터링, Auto Scaling 조정, 코드 성능 최적화, 커넥션 풀 확대                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |

위 점검·개선책을 순차적으로 적용하면, 빈번한 502 오류 원인을 제거하고 안정적인 서비스 통신을 구현할 수 있습니다.
