---
title: "클로저의 기본을 넘어서"
date: "240726"
tags: ["JavaScript"]
---

자바스크립트 개발자들은 인지하든 못하든 클로저에 대해 잘 알고 있습니다.

클로저에 대해 탐구하고 더 미묘한 응용 사례들을 살펴보았습니다.

## 클로저의 기원

클로저는 자바스크립트의 발명품이 아닙니다.

그 뿌리는 1930년대 Alonzo Church가 개발한 람다 계산법으로 거슬러 올라갑니다.

이 수학적 체계는 함수형 프로그래밍 언어의 기초를 마련했습니다.

```javascript
// 자바스크립트에서의 간단한 클로저
function outerFunction(x) {
  return function (y) {
    return x + y;
  };
}

const closure = outerFunction(5);
console.log(closure(3)); // 출력: 8
```

이 개념은 1958년 John McCarthy에 의해 Lisp에서 처음 구현되었고, 이후 1970년대 Scheme에서 더욱 정제되었습니다. 이러한 함수형 언어의 영향을 받은 자바스크립트는 클로저를 핵심 기능으로 채택했습니다.

## 자바스크립트에서 클로저를 사용하는 이유

1. **데이터 프라이버시와 캡슐화**

   클로저는 객체지향 원칙에 대한 함수형 접근 방식을 제공합니다.

   ```javascript
   function createCounter() {
     let count = 0;
     return {
       increment: () => ++count,
       decrement: () => --count,
       getCount: () => count,
     };
   }

   const counter = createCounter();
   console.log(counter.increment()); // 1
   console.log(counter.getCount()); // 1
   console.log(counter.count); // undefined
   ```

2. **상태 유지**

   클로저를 통해 함수는 호출 사이에 상태를 유지할 수 있습니다.

   ```javascript
   function memoize(fn) {
     const cache = {};
     return function (...args) {
       const key = JSON.stringify(args);
       if (key in cache) {
         return cache[key];
       }
       const result = fn.apply(this, args);
       cache[key] = result;
       return result;
     };
   }

   const expensiveOperation = memoize((x, y) => {
     console.log("계산 중...");
     return x + y;
   });

   console.log(expensiveOperation(4, 2)); // 계산 중... 6
   console.log(expensiveOperation(4, 2)); // 6 (캐시에서 반환)
   ```

3. **함수형 프로그래밍 지원**

   클로저는 고차 함수와 커링을 가능하게 합니다.

   ```javascript
   const curry = (fn) => {
     return function curried(...args) {
       if (args.length >= fn.length) {
         return fn.apply(this, args);
       } else {
         return function (...args2) {
           return curried.apply(this, args.concat(args2));
         };
       }
     };
   };

   const add = curry((a, b, c) => a + b + c);
   console.log(add(1)(2)(3)); // 6
   console.log(add(1, 2)(3)); // 6
   console.log(add(1, 2, 3)); // 6
   ```

4. **모듈 패턴**

   클로저를 사용하여 프라이빗 메서드와 변수를 가진 모듈을 만들 수 있습니다.

   ```javascript
   const myModule = (function () {
     let privateVariable = 0;

     function privateMethod() {
       console.log("프라이빗 메서드");
     }

     return {
       publicMethod: function () {
         privateVariable++;
         privateMethod();
       },
       getPrivateVariable: function () {
         return privateVariable;
       },
     };
   })();

   myModule.publicMethod();
   console.log(myModule.getPrivateVariable()); // 1
   ```

## 클로저의 고급 사용 사례

1. **비동기 프로그래밍**

   클로저는 콜백에서 외부 스코프의 변수에 접근할 수 있게 해줍니다.

   ```javascript
   function fetchData(url) {
     return new Promise((resolve, reject) => {
       const xhr = new XMLHttpRequest();
       xhr.open("GET", url);
       xhr.onload = function () {
         if (xhr.status === 200) {
           resolve(xhr.responseText);
         } else {
           reject(Error(xhr.statusText));
         }
       };
       xhr.onerror = function () {
         reject(Error("네트워크 오류"));
       };
       xhr.send();
     });
   }

   fetchData("https://api.example.com/data")
     .then((data) => console.log(data))
     .catch((error) => console.error(error));
   ```

2. **부분 적용과 함수 합성**

   클로저를 사용하여 함수의 일부 인자를 미리 적용하거나 여러 함수를 합성할 수 있습니다.

   ```javascript
   const partial =
     (fn, ...args) =>
     (...moreArgs) =>
       fn(...args, ...moreArgs);
   const compose =
     (...fns) =>
     (x) =>
       fns.reduceRight((v, f) => f(v), x);

   const add = (a, b) => a + b;
   const multiply = (a, b) => a * b;

   const add5 = partial(add, 5);
   const multiplyBy3 = partial(multiply, 3);

   const addThenMultiply = compose(multiplyBy3, add5);

   console.log(addThenMultiply(10)); // (10 + 5) * 3 = 45
   ```

## 결론

클로저는 단순한 프로그래밍 트릭 이상입니다. 그것은 자바스크립트의 핵심 기능으로, 데이터 은닉, 상태 관리, 함수형 프로그래밍 패러다임의 구현을 가능하게 합니다.

클로저의 힘을 이해하고 적절히 활용함으로써, 우리는 더 우아하고 효율적인 자바스크립트 코드를 작성할 수 있습니다.
