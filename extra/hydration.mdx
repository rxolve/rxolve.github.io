# Next.js 14에서의 Hydration 에러: 이해와 해결 방법

Next.js 14를 사용하면서 개발자들이 자주 마주치는 문제 중 하나가 바로 Hydration 에러입니다. 이 포스트에서는 Hydration 에러가 무엇인지, 왜 발생하는지, 그리고 어떻게 해결할 수 있는지에 대해 알아보겠습니다.

## Hydration 에러란?

Hydration 에러는 서버에서 렌더링된 HTML과 클라이언트에서 렌더링된 컴포넌트 트리가 일치하지 않을 때 발생합니다. 이는 주로 서버 사이드 렌더링(SSR)을 사용하는 애플리케이션에서 볼 수 있는 문제입니다.

예를 들어, 다음과 같은 에러 메시지를 보셨을 수 있습니다:

```
Warning: Text content did not match. Server: "Hello World" Client: "Hello User"
```

이는 서버에서 렌더링된 텍스트와 클라이언트에서 렌더링된 텍스트가 다르다는 것을 의미합니다.

## Hydration이 필요한 이유

Hydration은 서버에서 렌더링된 정적 HTML을 클라이언트 사이드 JavaScript와 연결하는 과정입니다. 이 과정이 필요한 이유는 다음과 같습니다:

1. **초기 로딩 성능 향상**: 서버에서 미리 렌더링된 HTML을 제공함으로써 초기 페이지 로딩 속도를 높입니다.
2. **SEO 최적화**: 검색 엔진이 JavaScript를 실행하지 않고도 콘텐츠를 크롤링할 수 있게 합니다.
3. **사용자 경험 개선**: 사용자는 JavaScript가 로드되기 전에도 콘텐츠를 볼 수 있습니다.

## Hydration 에러를 방지하는 방법

Hydration 에러를 방지하고 해결하기 위한 몇 가지 방법을 살펴보겠습니다:

### 1. 서버와 클라이언트의 일관성 유지

가장 중요한 것은 서버와 클라이언트에서 동일한 컨텐츠를 렌더링하는 것입니다. 예를 들어:

```jsx
// 잘못된 예
const Component = () => {
  return <div>{typeof window !== "undefined" ? "Client" : "Server"}</div>;
};

// 올바른 예
import { useEffect, useState } from "react";

const Component = () => {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return <div>{isClient ? "Client" : "Server"}</div>;
};
```

### 2. useEffect 활용

클라이언트 사이드에서만 실행되어야 하는 코드는 `useEffect` 훅 내부에 배치합니다:

```jsx
import { useEffect, useState } from "react";

const Component = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    // 클라이언트 사이드에서만 실행되는 코드
    fetchData().then(setData);
  }, []);

  if (!data) return null;

  return <div>{data}</div>;
};
```

### 3. Dynamic Imports 사용

클라이언트 사이드에서만 필요한 컴포넌트는 동적 임포트를 사용합니다:

```jsx
import dynamic from "next/dynamic";

const ClientOnlyComponent = dynamic(() => import("./ClientOnlyComponent"), {
  ssr: false,
});
```

### 4. next/script 활용

외부 스크립트를 불러올 때는 `next/script`를 사용하여 로딩 전략을 제어합니다:

```jsx
import Script from "next/script";

const Component = () => {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="lazyOnload" />
      {/* 컴포넌트 내용 */}
    </>
  );
};
```

### 5. 환경 변수 사용 주의

서버와 클라이언트에서 사용되는 환경 변수가 다를 수 있으므로, `NEXT_PUBLIC_` 접두사를 사용하여 클라이언트에서 접근 가능한 환경 변수를 명확히 구분합니다.

## 결론

Hydration 에러는 Next.js 애플리케이션에서 흔히 발생할 수 있는 문제지만, 적절한 이해와 기술을 통해 해결할 수 있습니다. 서버와 클라이언트의 일관성을 유지하고, 클라이언트 사이드 로직을 적절히 처리하며, Next.js의 기능들을 활용함으로써 보다 안정적이고 성능 좋은 애플리케이션을 개발할 수 있습니다.
