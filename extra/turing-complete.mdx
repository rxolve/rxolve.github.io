# Turing-complete: 계산 능력의 궁극적 기준

컴퓨터 과학의 세계에서 "Turing-complete"라는 용어는 자주 듣게 됩니다. 하지만 이 개념이 정확히 무엇을 의미하며, 왜 그렇게 중요한 걸까요? 이 포스트에서는 Turing-completeness의 개념을 깊이 있게 살펴보고, 현대 프로그래밍에 미치는 영향에 대해 알아보겠습니다.

## Turing-completeness란?

Turing-completeness는 어떤 프로그래밍 언어나 추상 기계가 튜링 기계와 동등한 계산 능력을 가지고 있다는 것을 의미합니다. 다시 말해, 튜링 기계로 계산할 수 있는 모든 것을 계산할 수 있는 시스템을 Turing-complete라고 합니다.

## 역사적 배경

이 개념은 Alan Turing이 1936년에 발표한 논문 "On Computable Numbers, with an Application to the Entscheidungsproblem"에서 처음 소개되었습니다. Turing은 이 논문에서 계산 가능성의 형식적 정의를 제시했고, 이는 현대 컴퓨터 과학의 기초가 되었습니다.

## Turing-completeness의 의미

Turing-complete 시스템은 다음과 같은 특징을 가집니다:

1. **보편성**: 모든 계산 가능한 함수를 구현할 수 있습니다.
2. **무한성**: 이론적으로 무한한 메모리를 가정합니다.
3. **조건부 분기**: 조건에 따라 다른 명령을 실행할 수 있습니다.
4. **반복**: 동일한 연산을 반복해서 수행할 수 있습니다.

## 현대 프로그래밍에서의 Turing-completeness

대부분의 현대 프로그래밍 언어들은 Turing-complete입니다. 하지만 몇 가지 흥미로운 예외와 경계 사례가 있습니다:

- **SQL**: 순수한 SQL은 Turing-complete가 아니지만, PL/SQL과 같은 확장은 Turing-complete입니다.
- **HTML+CSS**: CSS3와 HTML5는 함께 사용될 때 놀랍게도 Turing-complete입니다!
- **TypeScript의 타입 시스템**: TypeScript의 타입 시스템은 Turing-complete하여, 복잡한 타입 연산이 가능합니다.

```typescript
type Fibonacci<T extends number> = T extends 0 | 1
  ? 1
  : T extends 2
  ? 1
  : [...Fibonacci<Subtract<T, 1>>, ...Fibonacci<Subtract<T, 2>>]["length"];

type Result = Fibonacci<5>; // 5
```

## Turing-completeness의 함정

Turing-completeness는 강력하지만, 몇 가지 주의해야 할 점이 있습니다:

1. **정지 문제(Halting Problem)**: Turing-complete 시스템에서는 모든 프로그램이 종료될지 여부를 일반적으로 결정할 수 없습니다.
2. **복잡성**: Turing-complete 시스템은 때때로 필요 이상으로 복잡할 수 있습니다.
3. **보안**: 과도한 능력은 보안 취약점으로 이어질 수 있습니다.

## 결론

Turing-completeness는 컴퓨터 과학의 근본적인 개념이며, 현대 프로그래밍 언어와 시스템의 능력을 이해하는 데 중요합니다. 시스템이 Turing-complete인지 아닌지를 아는 것은 그 시스템의 능력과 한계를 이해하는 데 도움이 됩니다.

다음에는 여러분의 favorite 언어나 도구가 Turing-complete인지 한번 생각해보세요. 그리고 그것이 어떤 의미를 갖는지 고민해보는 것은 어떨까요?
