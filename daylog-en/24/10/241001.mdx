---
title: "Tidy First? 28. Reversible Structure Changes"
date: "241001"
tags: ["TidyFirst"]
---

> I read the Korean translation and translated it back into English, so the sentences may differ from the original.
>
> If you want to see the correct sentences, please purchase it from the link below:
>
> [Tidy First?: A Personal Exercise in Empirical Software Design](https://www.amazon.com/Tidy-First-Personal-Exercise-Empirical/dp/1098151240)

What's the difference between getting a bad haircut and getting a bad tattoo?

Hair grows back, so it's not a big deal. But a tattoo is permanent.

In general, decisions that can be reversed should be treated differently from those that cannot.

For decisions that cannot be undone, it's worth reviewing them carefully and checking twice or even three times.

We all want good results, but we're more afraid of bad outcomes.

What about decisions that can be reversed?

Since mistakes aren't such a big deal, you don't need to try too hard to avoid them.

This is the economic reality we're hinting at when we use the word "refactoring," and it's what we're explaining in this book.

How should we handle irreversible design changes?

For example, "extracting a service" is a relatively big change, so it can be hard to undo.

Do we need feature flags? Yes. Should we check feature flags everywhere?

Yes, let's refactor first. We only need to check the feature flags.

Another scenario where a reversible design decision becomes irreversible is when that decision spreads across the entire codebase.

Imagine changing an `integer` type to `long`, and now a million changes are needed. In that case:

1. Think more carefully about whether this decision might spread.
2. If it does, tackle it step by step, one at a time.

I learned the value of reversible decisions long before I knew the word "reversibility." And I came to understand how important it is to make decisions that can be undone.
