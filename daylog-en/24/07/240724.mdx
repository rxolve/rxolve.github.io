---
title: "The Easiest DP Problem"
date: "240724"
tags: ["Algorithm"]
---

# The Easiest DP Problem

When solving algorithm problems, it's impossible to avoid Dynamic Programming (DP). I'm going to summarize DP concepts using the easiest problem I know.

Let's explore the concept of DP with the simplest problem I'm familiar with.

## What is DP?

DP is a method of solving large problems by breaking them down into smaller ones. It's a smart approach that remembers the answers to small problems and reuses them later.

(I seem to really like problem-solving methods that involve breaking things down into smaller parts.)

## The 3 Core Principles of DP

1. **Problem Breakdown**: Divide the big problem into smaller problems.
2. **Answer Storage**: Store the answers to the smaller problems.
3. **Answer Reuse**: When the same small problem appears again, use the stored answer.

## Problem: Climbing Stairs

Let's see how DP is used in programming with the "Climbing Stairs" problem.

### Problem Description

- There are n stairs.
- You can climb either 1 or 2 stairs at a time.
- You need to find the number of ways to climb n stairs.

### Applying DP

1. **Small Problems**: The number of ways to climb 1, 2, 3... stairs
2. **Answer Storage**: Store the number of ways for each number of stairs in an array
3. **Reuse**: Ways to climb n stairs = (Ways to climb n-1 stairs) + (Ways to climb n-2 stairs)

### Code Implementation

```typescript
function climbStairs(n: number): number {
  if (n <= 1) return 1;

  // Initialize dp array
  let dp: number[] = new Array(n + 1);

  // Base cases
  dp[0] = 1;
  dp[1] = 1;

  // DP logic
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  // Return the number of ways to climb n stairs
  return dp[n];
}

// Test
console.log(climbStairs(2)); // Output: 2
console.log(climbStairs(3)); // Output: 3
console.log(climbStairs(5)); // Output: 8
```

This code works as follows:

1. If `n` is 1 or less, the number of ways is 1.
2. Create a `dp` array to store the number of ways to reach each stair.
3. Base cases: There is 1 way to reach the 0th and 1st stair.
4. Iterate from 2 to n, calculating the number of ways to reach each stair.
   The number of ways to reach the i-th stair is the sum of ways to reach
   the (i-1)th stair (climbing 1 step) and the (i-2)th stair (climbing 2 steps).
5. Finally, return the number of ways to reach the nth stair.

## Summary

This is how DP efficiently solves problems by reusing previously calculated results. It breaks down a big problem (climbing n stairs) into smaller problems (climbing 1, 2, 3... stairs), and uses the solutions to small problems to solve the big problem.

We've solved a simple DP problem. I hope you'll try tackling more complex problems too! ðŸš€
