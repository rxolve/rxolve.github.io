---
title: "Object.keys() vs Object.getOwnPropertyNames()"
date: "240825"
tags: ["JavaScript"]
---

JavaScript 개발자라면 `Object.keys()`와 `Object.getOwnPropertyNames()`를 사용해 본 적이 있을 것입니다.

하지만 이 두 메서드의 미묘한 차이점이 궁금했습니다.

## 기본적인 차이점

먼저, 두 메서드의 기본적인 차이점을 코드로 살펴보겠습니다.

```javascript
const obj = Object.create(null);
obj.a = 1;
obj.b = 2;

Object.defineProperty(obj, "c", {
  value: 3,
  enumerable: false,
});

const symbolProp = Symbol("d");
obj[symbolProp] = 4;

console.log(Object.keys(obj)); // ['a', 'b']
console.log(Object.getOwnPropertyNames(obj)); // ['a', 'b', 'c']
```

주요 차이점:

1. `Object.keys()`는 열거 가능한 속성만 반환합니다.
2. `Object.getOwnPropertyNames()`는 열거 가능 여부와 관계없이 모든 문자열 키의 속성을 반환합니다.
3. 둘 다 심볼 속성은 반환하지 않습니다.

## 고급 활용 사례

### 1. 프라이빗 속성 구현

ES6 이전에는 프라이빗 속성을 시뮬레이션하기 위해 열거 불가능한 속성을 사용했습니다.

`Object.getOwnPropertyNames()`를 활용하면 이러한 "프라이빗" 속성에 접근할 수 있습니다.

```javascript
function CreatePerson(name) {
  Object.defineProperty(this, "_name", {
    value: name,
    enumerable: false,
  });
}

CreatePerson.prototype.getName = function () {
  return this._name;
};

const person = new CreatePerson("Alice");
console.log(Object.keys(person)); // []
console.log(Object.getOwnPropertyNames(person)); // ['_name']
```

### 2. 메타프로그래밍과 리플렉션

메타프로그래밍에서 `Object.getOwnPropertyNames()`는 객체의 모든 속성을 검사하는 데 유용합니다.

```javascript
function inspectObject(obj) {
  const properties = Object.getOwnPropertyNames(obj);
  properties.forEach((prop) => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    console.log(`${prop}: ${JSON.stringify(descriptor)}`);
  });
}

class Example {
  constructor() {
    this.visible = true;
  }
  #hidden = "secret";
  static staticProp = "static";
}

inspectObject(new Example());
inspectObject(Example);
```

### 3. 심볼 속성 다루기

심볼 속성을 포함한 모든 속성을 가져오려면 다음과 같은 방법을 사용할 수 있습니다:

```javascript
function getAllProperties(obj) {
  return [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj),
  ];
}

const sym = Symbol("mySymbol");
const obj = { a: 1, [sym]: 2 };

console.log(getAllProperties(obj)); // ['a', Symbol(mySymbol)]
```

## 성능 고려사항

대규모 객체를 다룰 때 `Object.keys()`와 `Object.getOwnPropertyNames()`의 성능 차이를 고려해야 합니다.

일반적으로 `Object.keys()`가 더 빠르지만, 열거 불가능한 속성이 많은 경우 `Object.getOwnPropertyNames()`가 필요할 수 있습니다.

```javascript
function benchmark(fn, iterations = 1000000) {
  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    fn();
  }
  return performance.now() - start;
}

const testObj = {};
for (let i = 0; i < 100; i++) {
  testObj[`prop${i}`] = i;
  if (i % 2 === 0) {
    Object.defineProperty(testObj, `hidden${i}`, {
      value: i,
      enumerable: false,
    });
  }
}

console.log(`Object.keys(): ${benchmark(() => Object.keys(testObj))}ms`);
console.log(
  `Object.getOwnPropertyNames(): ${benchmark(() =>
    Object.getOwnPropertyNames(testObj)
  )}ms`
);
```
