---
title: "BFS와 맨해튼 거리 알고리즘"
date: "241013"
tags: ["Algorithms"]
---

BFS와 맨해튼 거리는 경로 탐색 문제를 해결할 때 자주 사용되는 알고리즘입니다.

특히 그리드 기반 환경에서는 두 개념을 함께 사용하면 효율적인 경로 탐색이 가능합니다.

## 맨해튼 거리

맨해튼 거리는 두 점 사이의 이동 경로가 수직 또는 수평으로만 이루어질 수 있을 때 사용됩니다.

이름에서 알 수 있듯이 뉴욕의 맨해튼 거리 구조(직각으로 배열된 블록)에서 유래되었습니다.

#### 공식

> D = |x_1 - x_2| + |y_1 - y_2|

- \( (x_1, y_1) \)과 \( (x_2, y_2) \) 사이의 절댓값 차이를 더한 값입니다.
- 이 거리는 대각선 이동을 허용하지 않는 환경에서 유용합니다.

#### 간단한 예제

```typescript
type Point = { x: number; y: number };

function manhattanDistance(pointA: Point, pointB: Point): number {
  return Math.abs(pointA.x - pointB.x) + Math.abs(pointA.y - pointB.y);
}

// 사용 예제
const p1: Point = { x: 1, y: 2 };
const p2: Point = { x: 4, y: 6 };

console.log(`Manhattan Distance: ${manhattanDistance(p1, p2)}`);
// 출력: Manhattan Distance: 7
```

위 코드에서는 두 점 `(1, 2)`와 `(4, 6)` 사이의 맨해튼 거리를 계산하여 `7`이라는 결과를 출력합니다.

---

## BFS 알고리즘

BFS는 최단 경로를 찾는 데 적합한 알고리즘으로, 그래프나 2D 배열에서 주로 사용됩니다.

BFS는 시작점에서 가까운 노드부터 차례로 방문하며, 최단 거리를 찾기 위해 유용합니다.

#### BFS의 특징

- Queue(큐)를 사용하여 탐색을 진행합니다.
- 모든 방향으로 한 단계씩 확장하며 목표 지점에 도달합니다.
- 가중치가 동일한 그래프나 그리드에서 최단 경로를 보장합니다.

---

## BFS와 맨해튼 거리의 조합

BFS 알고리즘은 장애물이 있는 그리드에서 최단 경로를 탐색할 때 유용합니다.

이때 상하좌우 방향으로만 이동할 수 있는 문제에서는 맨해튼 거리가 유용한 보조 도구가 됩니다.

#### 예제 문제

아래와 같은 2D 배열(그리드)이 주어졌을 때 `(0, 0)`에서 `(3, 2)`로 가는 최단 거리를 찾으세요.

1은 장애물, 0은 이동 가능한 위치입니다.

```text
0 0 1 0
1 0 1 0
0 0 0 0
1 1 0 0
```

```typescript
type Point = { x: number; y: number };
type Grid = number[][];

const bfsWithManhattan = (grid: Grid, start: Point, end: Point): number => {
  const directions = [
    { x: 1, y: 0 }, // 오른쪽
    { x: -1, y: 0 }, // 왼쪽
    { x: 0, y: 1 }, // 아래쪽
    { x: 0, y: -1 }, // 위쪽
  ];

  const rows = grid.length;
  const cols = grid[0].length;
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  const queue: { point: Point; distance: number }[] = [
    { point: start, distance: 0 },
  ];

  visited[start.y][start.x] = true;

  while (queue.length > 0) {
    const { point, distance } = queue.shift()!;

    // 목표 지점 도달 시 거리 반환
    if (point.x === end.x && point.y === end.y) return distance;

    // 상하좌우로 이동
    for (const dir of directions) {
      const newX = point.x + dir.x;
      const newY = point.y + dir.y;

      // 그리드 범위 내에 있고, 방문하지 않았으며, 장애물이 아닌 경우 이동
      if (
        newX >= 0 &&
        newX < cols &&
        newY >= 0 &&
        newY < rows &&
        grid[newY][newX] === 0 &&
        !visited[newY][newX]
      ) {
        visited[newY][newX] = true;
        queue.push({ point: { x: newX, y: newY }, distance: distance + 1 });
      }
    }
  }

  return -1; // 목표 지점에 도달할 수 없는 경우
};

// 사용 예제
const grid: Grid = [
  [0, 0, 1, 0],
  [1, 0, 1, 0],
  [0, 0, 0, 0],
  [1, 1, 0, 0],
];

const start: Point = { x: 0, y: 0 };
const end: Point = { x: 3, y: 2 };

const result = bfsWithManhattan(grid, start, end);
console.log(`최단 거리: ${result}`);
// 출력: 최단 거리: 5
```

---

## 코드 해설

#### 상하좌우 방향 배열

`directions` 배열은 상하좌우로 이동하기 위한 좌표 변화를 정의합니다. BFS는 이 네 방향으로만 확장됩니다.

#### 방문 체크 배열

`visited` 배열은 특정 지점을 이미 방문했는지 여부를 기록합니다. 방문한 지점을 다시 탐색하지 않도록 하여 불필요한 계산을 방지합니다.

#### BFS 탐색 진행

BFS는 큐에 시작점을 넣고, 큐가 빌 때까지 반복합니다. 목표 지점에 도달하면 해당 거리를 반환합니다. 만약 도달할 수 없을 경우 `-1`을 반환합니다.

---

## 예제 결과

위의 코드에서 `(0, 0)`에서 `(3, 2)`로 가는 최단 거리는 5입니다. BFS는 다음과 같은 경로를 찾습니다:

```text
(0, 0) → (0, 1) → (1, 1) → (2, 1) → (2, 2) → (3, 2)
```
