---
title: "2-3 트리: 삭제"
date: "240908"
tags: ["Algorithm"]
---

이전에 2-3 트리의 삽입 연산에 대해 알아보았습니다. 이번에는 2-3 트리에서의 삭제 연산을 살펴보겠습니다.

#### 2-3 트리 삭제 특징

- 삭제 후에도 모든 리프 노드는 같은 깊이를 유지해야 합니다.
- 2-노드에서 키를 삭제할 때 특별한 처리가 필요합니다.
- 내부 노드에서 키를 삭제할 때는 후속자나 선행자로 대체합니다.

#### 2-3 트리 삭제 과정

2-3 트리에서 값을 삭제하는 과정을 단계별로 살펴보겠습니다.

1. 삭제할 키 찾기

- 루트에서 시작하여 삭제할 키를 찾을 때까지 트리를 탐색합니다.

2. 리프 노드에서의 삭제

- 키가 리프 노드에 있다면 직접 삭제합니다.
- 3-노드라면 간단히 키를 제거하고 종료합니다.
- 2-노드라면 추가 작업이 필요합니다 (아래 '부족 상태 해결' 참조).

3. 내부 노드에서의 삭제

- 키가 내부 노드에 있다면, 후속자나 선행자로 대체합니다.
- 대체 후 리프 노드에서의 삭제 문제로 전환됩니다.

4. 부족 상태(underflow) 해결

- 2-노드에서 키를 삭제하면 노드가 비게 되어 '부족 상태'가 됩니다.
- 형제 노드에서 키를 빌리거나(재분배) 부모와 형제를 병합합니다.

5. 변경 사항 전파

- 필요한 경우 변경 사항을 루트까지 전파시킵니다.
- 루트가 비게 되면 트리의 높이가 감소할 수 있습니다.

#### 예시

숫자 7을 다음과 같은 2-3 트리에서 삭제하는 과정을 살펴보겠습니다.

```
         [9]
        /   \
     [5]     [15]
    /   \    /   \
 [2,3] [7] [10] [17,20]
```

1. 7을 찾아 삭제합니다: [7] 노드가 비게 됩니다.
2. 부족 상태를 해결해야 합니다:
   - 왼쪽 형제 [2,3]에서 3을 빌립니다.
   - 부모의 5를 [7]의 자리로 내립니다.
   - 3을 부모로 올립니다.
3. 변경 사항을 반영합니다.

결과는 다음과 같습니다.

```
         [9]
        /   \
     [3]     [15]
    /   \    /   \
 [2]   [5] [10] [17,20]
```

#### 부족 상태 해결 방법

1. 재분배 (형제에서 빌리기)

   - 인접한 형제가 3-노드라면 키를 빌려올 수 있습니다.
   - 형제의 키, 부모의 키, 현재 노드를 재배열합니다.

2. 병합
   - 인접한 형제가 2-노드라면 병합이 필요합니다.
   - 부모의 키를 형제 노드로 내리고, 비어있는 노드를 제거합니다.
   - 부모 노드의 키가 줄어들어 부족 상태가 될 수 있으므로 재귀적으로 처리합니다.

#### 삭제 과정 정리

<Mermaid
  chart={`
graph TD
A[Step 1: 삭제할 키 찾기] --> B{리프 노드인가?}
B -->|Yes| C[Step 2: 리프에서 삭제]
B -->|No| D[Step 3: 내부 노드 삭제]
D --> E[후속자/선행자로 대체]
E --> C
C --> F{노드가 비었는가?}
F -->|No| G[삭제 완료]
F -->|Yes| H[Step 4: 부족 상태 해결]
H --> I{형제가 3-노드인가?}
I -->|Yes| J[재분배]
I -->|No| K[병합]
J --> L[Step 5: 변경사항 전파]
K --> L
L --> M{루트까지 처리 완료?}
M -->|No| H
M -->|Yes| N[삭제 완료]
`}
/>

#### 마치며

2-3 트리의 삭제 연산은 삽입에 비해 더 복잡할 수 있습니다. 하지만 이 과정을 이해하면 다른 균형 트리 구조의 삭제 연산도 쉽게 이해할 수 있습니다.

다음에는 2-3 트리의 실제 구현과 성능 분석에 대해 알아보겠습니다.
