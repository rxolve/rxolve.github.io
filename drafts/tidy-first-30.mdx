---
title: "Tidy First? 30. 콘스탄틴의 등가성"
date: "241003"
tags: ["TidyFirst"]
---

> 정리하며 책의 문장을 요약해서 옮깁니다.

젊은 프로그래머 시절, 소프트웨어 개발 비용의 70%가 유지보수에 들어간다는 끔찍한 보고를 들었던 기억이 납니다.

자그마치 70퍼센트입니다!

결합도와 응집도에 관한 최도의 연구인 `Structured Design`에서 스프트웨어 설계의 목표는 소프트웨어의 비용을 최소화하는 것이라고 가정했습니다.

제가 '콘스탄틴의 등가성'이라고 이름 붙인 이 용어에 따르면, 소프트웨어 비용은 그것을 변경하는 데 드는 비용과 거의 같습니다.

> 비용(소프트웨어) ~= 비용(변경)

소프트웨어의 수명 주기에 따른 누적 비용을 그래프로 나타내면, 로그 함수 곡선과 같은 모양을 얻을 수 있습니다.

<Mermaid
  chart={`
graph LR
  A[0, 0] --> B(1, 0.69)
  B --> C(2, 1.1)
  C --> D(3, 1.39)
  D --> E(4, 1.61)
  E --> F(5, 1.79)
`}
/>

출시 전 기간은 전체 시간 중에서 작은 부분을 차지하고, 총 비용 중에서도 작은 부분을 차지합니다.

그러던 어느 날 표면적으로는 이전의 모든 변경 사항과 유사한 변경 사항을 적용했을 뿐인데, 이번 것은 우리 눈앞에서 폭발하고 맙니다.

한 단위가 아니라 열 배, 백 배, 천 배로 비용이 증가합니다. 기존 시스템과의 마찰도 함께 일어나기 때문입니다.

멱법칙 분포에 대해 알고 있다면, 여기서 무슨 일이 벌어지고 있는지 알 수 있을 것입니다.

멱법칙 분포의 하 가지 특징은 소수의 큰 '이상값'을 발생시키는 일이 매우 중요하다는 것입니다.

그것들을 합치면 훨씬 더 많은 '정상' 사건보다 더 큰 영향을 미칩니다. 가장 큰 다섯 폭풍이 작은 폭풍 만 개보다 더 큰 피해를 입히는 법이죠.

다시 말해, 변경 비용은 큰 변경들의 비용과 거의 같다는 뜻입니다.

> 비용(전체 변경) ~= 비용(큰 변경들)

큰 변경들의 비용이 비싼 이유는 무엇일까요? 무엇이 변경을 '전파'할까요? 바로 결합도 입니다.

> 비용(큰 변경들) ~= 결합도

이제 우리는 완전한 콘스탄틴의 등식을 얻었습니다.

> 비용(소프트웨어) ~= 비용(전체 변경) ~= 비용(큰 변경들) ~= 결합도

따라서 소프트웨어의 비용을 줄이려면 결합도를 줄여야 합니다.

하지만 결합도를 줄이는 것은 공짜가 아니며 절충점을 피할 수 없습니다.
